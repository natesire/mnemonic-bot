{"ast":null,"code":"\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\nconst factoryValidator = require(\"./factoryValidator\");\nconst PoolOptions = require(\"./PoolOptions\");\nconst ResourceRequest = require(\"./ResourceRequest\");\nconst ResourceLoan = require(\"./ResourceLoan\");\nconst PooledResource = require(\"./PooledResource\");\nconst DefaultEvictor = require(\"./DefaultEvictor\");\nconst Deque = require(\"./Deque\");\nconst Deferred = require(\"./Deferred\");\nconst PriorityQueue = require(\"./PriorityQueue\");\nconst DequeIterator = require(\"./DequeIterator\");\nconst reflector = require(\"./utils\").reflector;\n\n/**\n * TODO: move me\n */\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n    factoryValidator(factory);\n    this._config = new PoolOptions(options);\n\n    // TODO: fix up this ugly glue-ing\n    this._Promise = this._config.Promise;\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n    this._factoryCreateOperations = new Set();\n\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n    this._factoryDestroyOperations = new Set();\n\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n    this._availableObjects = new Deque();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n    this._testOnBorrowResources = new Set();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n    this._testOnReturnResources = new Set();\n\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n    this._validationOperations = new Set();\n\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n    this._allObjects = new Set();\n\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n    this._resourceLoans = new Map();\n\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n    this._evictionIterator = this._availableObjects.iterator();\n    this._evictor = new Evictor();\n\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n    this._scheduledEviction = null;\n\n    // create initial resources (if factory.min > 0)\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n    this._allObjects.delete(pooledResource);\n    // NOTE: this maybe very bad promise usage?\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n    const wrappedDestroyPromise = this._config.destroyTimeoutMillis ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise)) : this._Promise.resolve(destroyPromise);\n    this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    });\n\n    // TODO: maybe ensuring minimum pool size should live outside here\n    this._ensureMinimum();\n  }\n  _applyDestroyTimeout(promise) {\n    const timeoutPromise = new this._Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(new Error(\"destroy timed out\"));\n      }, this._config.destroyTimeoutMillis).unref();\n    });\n    return this._Promise.race([timeoutPromise, promise]);\n  }\n\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n    const pooledResource = this._availableObjects.shift();\n    // Mark the resource as in test\n    pooledResource.test();\n    this._testOnBorrowResources.add(pooledResource);\n    const validationPromise = this._factory.validate(pooledResource.obj);\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n    this._trackOperation(wrappedValidationPromise, this._validationOperations).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n      if (isValid === false) {\n        pooledResource.invalidate();\n        this._destroy(pooledResource);\n        this._dispense();\n        return;\n      }\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n    return true;\n  }\n\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n    const pooledResource = this._availableObjects.shift();\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    return false;\n  }\n\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length;\n\n    // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n    if (numWaitingClients < 1) {\n      return;\n    }\n    const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;\n    const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    }\n\n    // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    }\n\n    // if we aren't testing-on-borrow then lets try to allocate what we can\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n    if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource);\n      // TODO: do need to trigger anything before we leave?\n      return false;\n    }\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n    this._resourceLoans.set(pooledResource.obj, loan);\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n  _trackOperation(operation, set) {\n    set.add(operation);\n    return operation.then(v => {\n      set.delete(operation);\n      return this._Promise.resolve(v);\n    }, e => {\n      set.delete(operation);\n      return this._Promise.reject(e);\n    });\n  }\n\n  /**\n   * @private\n   */\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n    const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then(resource => {\n      const pooledResource = new PooledResource(resource);\n      this._allObjects.add(pooledResource);\n      this._addPooledResourceToAvailableObjects(pooledResource);\n    });\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {\n      this._dispense();\n      // Stop bluebird complaining about this side-effect only handler\n      // - a promise was created in a handler but was not returned from it\n      // https://goo.gl/rRqMUw\n      return null;\n    }).catch(reason => {\n      this.emit(FACTORY_CREATE_ERROR, reason);\n      this._dispense();\n    });\n  }\n\n  /**\n   * @private\n   */\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n    const minShortfall = this._config.min - this._count;\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n  _evict() {\n    const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun;) {\n      const iterationResult = this._evictionIterator.next();\n\n      // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after checking its length.\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n        return;\n      }\n      // If this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n        continue;\n      }\n      const resource = iterationResult.value;\n      const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);\n      testsHaveRun++;\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n        this._destroy(resource);\n      }\n    }\n  }\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n    this._scheduledEviction = null;\n  }\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n    if (this._started === true) {\n      return;\n    }\n    this._started = true;\n    this._scheduleEvictorRun();\n    this._ensureMinimum();\n  }\n\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n    if (this._draining) {\n      return this._Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    }\n\n    // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n    if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {\n      return this._Promise.reject(new Error(\"max waitingClients count exceeded\"));\n    }\n    const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n    this._dispense();\n    return resourceRequest.promise;\n  }\n\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n  use(fn, priority) {\n    return this.acquire(priority).then(resource => {\n      return fn(resource).then(result => {\n        this.release(resource);\n        return result;\n      }, err => {\n        this.destroy(resource);\n        throw err;\n      });\n    });\n  }\n\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n    this._addPooledResourceToAvailableObjects(pooledResource);\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n    this._destroy(pooledResource);\n    this._dispense();\n    return this._Promise.resolve();\n  }\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled().then(() => {\n      return this.__allResourcesReturned();\n    }).then(() => {\n      this._descheduleEvictorRun();\n    });\n  }\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n    return this._Promise.resolve();\n  }\n\n  // FIXME: this is a horrific mess\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values()).map(loan => loan.promise).map(reflector);\n    return this._Promise.all(ps);\n  }\n\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n  clear() {\n    const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector);\n\n    // wait for outstanding factory.create to complete\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n      const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n\n  /**\n   * Waits until the pool is ready.\n   * We define ready by checking if the current resource number is at least\n   * the minimum number defined.\n   * @returns {Promise} that resolves when the minimum number is ready.\n   */\n  ready() {\n    return new this._Promise(resolve => {\n      const isReady = () => {\n        if (this.available >= this.min) {\n          resolve();\n        } else {\n          setTimeout(isReady, 100);\n        }\n      };\n      isReady();\n    });\n  }\n\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n  get _potentiallyAllocableResourceCount() {\n    return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;\n  }\n\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n  get spareResourceCapacity() {\n    return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);\n  }\n\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n  get size() {\n    return this._count;\n  }\n\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n  get max() {\n    return this._config.max;\n  }\n\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n  get min() {\n    return this._config.min;\n  }\n}\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","factoryValidator","PoolOptions","ResourceRequest","ResourceLoan","PooledResource","DefaultEvictor","Deque","Deferred","PriorityQueue","DequeIterator","reflector","FACTORY_CREATE_ERROR","FACTORY_DESTROY_ERROR","Pool","constructor","Evictor","factory","options","_config","_Promise","Promise","_factory","_draining","_started","_waitingClientsQueue","priorityRange","_factoryCreateOperations","Set","_factoryDestroyOperations","_availableObjects","_testOnBorrowResources","_testOnReturnResources","_validationOperations","_allObjects","_resourceLoans","Map","_evictionIterator","iterator","_evictor","_scheduledEviction","autostart","start","_destroy","pooledResource","invalidate","delete","destroyPromise","destroy","obj","wrappedDestroyPromise","destroyTimeoutMillis","resolve","_applyDestroyTimeout","_trackOperation","catch","reason","emit","_ensureMinimum","promise","timeoutPromise","reject","setTimeout","Error","unref","race","_testOnBorrow","length","shift","test","add","validationPromise","validate","wrappedValidationPromise","then","isValid","_dispense","_dispatchPooledResourceToNextWaitingClient","_dispatchResource","numWaitingClients","resourceShortfall","_potentiallyAllocableResourceCount","actualNumberOfResourcesToCreate","Math","min","spareResourceCapacity","i","_createResource","testOnBorrow","desiredNumberOfResourcesToMoveIntoTest","size","actualNumberOfResourcesToMoveIntoTest","actualNumberOfResourcesToDispatch","clientResourceRequest","dequeue","undefined","state","PENDING","_addPooledResourceToAvailableObjects","loan","set","allocate","operation","v","e","factoryPromise","create","wrappedFactoryPromise","resource","minShortfall","_count","_evict","testsToRun","numTestsPerEvictionRun","evictionConfig","softIdleTimeoutMillis","idleTimeoutMillis","testsHaveRun","iterationResult","next","done","reset","value","shouldEvict","evict","remove","_scheduleEvictorRun","evictionRunIntervalMillis","_descheduleEvictorRun","clearTimeout","acquire","priority","maxWaitingClients","resourceRequest","acquireTimeoutMillis","enqueue","use","fn","result","release","err","isBorrowedResource","has","get","deallocate","idle","fifo","push","unshift","drain","__allResourceRequestsSettled","__allResourcesReturned","tail","ps","Array","from","values","map","all","clear","reflectedCreatePromises","reflectedDestroyPromises","ready","isReady","available","max","borrowed","pending","module","exports"],"sources":["C:/Users/nates/Pro/anagrams/node_modules/generic-pool/lib/Pool.js"],"sourcesContent":["\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\nconst PoolOptions = require(\"./PoolOptions\");\nconst ResourceRequest = require(\"./ResourceRequest\");\nconst ResourceLoan = require(\"./ResourceLoan\");\nconst PooledResource = require(\"./PooledResource\");\nconst DefaultEvictor = require(\"./DefaultEvictor\");\nconst Deque = require(\"./Deque\");\nconst Deferred = require(\"./Deferred\");\nconst PriorityQueue = require(\"./PriorityQueue\");\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n\n/**\n * TODO: move me\n */\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n\n    factoryValidator(factory);\n\n    this._config = new PoolOptions(options);\n\n    // TODO: fix up this ugly glue-ing\n    this._Promise = this._config.Promise;\n\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n    this._factoryCreateOperations = new Set();\n\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n    this._factoryDestroyOperations = new Set();\n\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n    this._availableObjects = new Deque();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n    this._testOnBorrowResources = new Set();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n    this._testOnReturnResources = new Set();\n\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n    this._validationOperations = new Set();\n\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n    this._allObjects = new Set();\n\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n    this._resourceLoans = new Map();\n\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n    this._evictionIterator = this._availableObjects.iterator();\n\n    this._evictor = new Evictor();\n\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n    this._scheduledEviction = null;\n\n    // create initial resources (if factory.min > 0)\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n    this._allObjects.delete(pooledResource);\n    // NOTE: this maybe very bad promise usage?\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n    const wrappedDestroyPromise = this._config.destroyTimeoutMillis\n      ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise))\n      : this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(\n      wrappedDestroyPromise,\n      this._factoryDestroyOperations\n    ).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    });\n\n    // TODO: maybe ensuring minimum pool size should live outside here\n    this._ensureMinimum();\n  }\n\n  _applyDestroyTimeout(promise) {\n    const timeoutPromise = new this._Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(new Error(\"destroy timed out\"));\n      }, this._config.destroyTimeoutMillis).unref();\n    });\n    return this._Promise.race([timeoutPromise, promise]);\n  }\n\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    // Mark the resource as in test\n    pooledResource.test();\n    this._testOnBorrowResources.add(pooledResource);\n    const validationPromise = this._factory.validate(pooledResource.obj);\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(\n      wrappedValidationPromise,\n      this._validationOperations\n    ).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n        this._destroy(pooledResource);\n        this._dispense();\n        return;\n      }\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    return false;\n  }\n\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length;\n\n    // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall =\n      numWaitingClients - this._potentiallyAllocableResourceCount;\n\n    const actualNumberOfResourcesToCreate = Math.min(\n      this.spareResourceCapacity,\n      resourceShortfall\n    );\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    }\n\n    // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest =\n        numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(\n        this._availableObjects.length,\n        desiredNumberOfResourcesToMoveIntoTest\n      );\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    }\n\n    // if we aren't testing-on-borrow then lets try to allocate what we can\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(\n        this._availableObjects.length,\n        numWaitingClients\n      );\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n    if (\n      clientResourceRequest === undefined ||\n      clientResourceRequest.state !== Deferred.PENDING\n    ) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource);\n      // TODO: do need to trigger anything before we leave?\n      return false;\n    }\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n    this._resourceLoans.set(pooledResource.obj, loan);\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n  _trackOperation(operation, set) {\n    set.add(operation);\n\n    return operation.then(\n      v => {\n        set.delete(operation);\n        return this._Promise.resolve(v);\n      },\n      e => {\n        set.delete(operation);\n        return this._Promise.reject(e);\n      }\n    );\n  }\n\n  /**\n   * @private\n   */\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n    const wrappedFactoryPromise = this._Promise\n      .resolve(factoryPromise)\n      .then(resource => {\n        const pooledResource = new PooledResource(resource);\n        this._allObjects.add(pooledResource);\n        this._addPooledResourceToAvailableObjects(pooledResource);\n      });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations)\n      .then(() => {\n        this._dispense();\n        // Stop bluebird complaining about this side-effect only handler\n        // - a promise was created in a handler but was not returned from it\n        // https://goo.gl/rRqMUw\n        return null;\n      })\n      .catch(reason => {\n        this.emit(FACTORY_CREATE_ERROR, reason);\n        this._dispense();\n      });\n  }\n\n  /**\n   * @private\n   */\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n    const minShortfall = this._config.min - this._count;\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(\n      this._config.numTestsPerEvictionRun,\n      this._availableObjects.length\n    );\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun; ) {\n      const iterationResult = this._evictionIterator.next();\n\n      // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after checking its length.\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n        return;\n      }\n      // If this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(\n        evictionConfig,\n        resource,\n        this._availableObjects.length\n      );\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n    if (this._started === true) {\n      return;\n    }\n    this._started = true;\n    this._scheduleEvictorRun();\n    this._ensureMinimum();\n  }\n\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(\n        new Error(\"pool is draining and cannot accept work\")\n      );\n    }\n\n    // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n    if (\n      this.spareResourceCapacity < 1 &&\n      this._availableObjects.length < 1 &&\n      this._config.maxWaitingClients !== undefined &&\n      this._waitingClientsQueue.length >= this._config.maxWaitingClients\n    ) {\n      return this._Promise.reject(\n        new Error(\"max waitingClients count exceeded\")\n      );\n    }\n\n    const resourceRequest = new ResourceRequest(\n      this._config.acquireTimeoutMillis,\n      this._Promise\n    );\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n  use(fn, priority) {\n    return this.acquire(priority).then(resource => {\n      return fn(resource).then(\n        result => {\n          this.release(resource);\n          return result;\n        },\n        err => {\n          this.destroy(resource);\n          throw err;\n        }\n      );\n    });\n  }\n\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._destroy(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled()\n      .then(() => {\n        return this.__allResourcesReturned();\n      })\n      .then(() => {\n        this._descheduleEvictorRun();\n      });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n    return this._Promise.resolve();\n  }\n\n  // FIXME: this is a horrific mess\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values())\n      .map(loan => loan.promise)\n      .map(reflector);\n    return this._Promise.all(ps);\n  }\n\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n  clear() {\n    const reflectedCreatePromises = Array.from(\n      this._factoryCreateOperations\n    ).map(reflector);\n\n    // wait for outstanding factory.create to complete\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n      const reflectedDestroyPromises = Array.from(\n        this._factoryDestroyOperations\n      ).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n\n  /**\n   * Waits until the pool is ready.\n   * We define ready by checking if the current resource number is at least\n   * the minimum number defined.\n   * @returns {Promise} that resolves when the minimum number is ready.\n   */\n  ready() {\n    return new this._Promise(resolve => {\n      const isReady = () => {\n        if (this.available >= this.min) {\n          resolve();\n        } else {\n          setTimeout(isReady, 100);\n        }\n      };\n\n      isReady();\n    });\n  }\n\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n  get _potentiallyAllocableResourceCount() {\n    return (\n      this._availableObjects.length +\n      this._testOnBorrowResources.size +\n      this._testOnReturnResources.size +\n      this._factoryCreateOperations.size\n    );\n  }\n\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n  get spareResourceCapacity() {\n    return (\n      this._config.max -\n      (this._allObjects.size + this._factoryCreateOperations.size)\n    );\n  }\n\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n  get size() {\n    return this._count;\n  }\n\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n  get max() {\n    return this._config.max;\n  }\n\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n  get min() {\n    return this._config.min;\n  }\n}\n\nmodule.exports = Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}